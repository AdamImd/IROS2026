\section{Methodology}
\label{sec:methodology}


\subsection{Tactile Sensor Design}
\label{sec:sensor_design}
We design a tactile sensor that can be easily integrated onto the Boston Dynamics Spot robot arm, providing whole-arm tactile sensing with high spatial resolution and sensitivity. The sensor is designed to be low-cost, with a BOM of less than \$100, and easy to manufacture using 3D printing and off-the-shelf components.

The sensor consists of a 3D printed inner shell that snaps onto the arm of the robot, and an outer shell that can deform under contact forces. Between the inner and outer shell, we place a layer of piezoelectric conductive fabric that acts as a force-sensitive resistor (FSR). The inner and outer shells are designed to create a grid of sensing cells, where each cell corresponds to a specific location on the arm. The sensor is connected to a micro-controller that reads the voltage across each cell, allowing us to estimate the contact force and location.

The sensor is designed to be robust to environmental factors, such as sharp objects, dirt, and moisture. The outer shell is made from a 95A shore hardness TPU, which provides a good balance between flexibility and durability. The inner shell is made from a rigid material, such as PLA or ABS, to provide structural support and ensure a secure fit onto the arm. We use a highly conductive copper tape to create the sensor traces, which easily cut using the internal traces in the 3D printed shells. The sensor is designed to be modular, allowing us to easily replace or upgrade individual components as needed. The layers are assembled using a needle and thread, sewing the conductive fabric to the inner shell, and the outer shell is then sewed on top, creating a sealed unit that protects the internal components.

\subsection{Inverse Kinematics with Contact-Aware Conditioning}
\label{sec:contact_ik}
Given a robot arm with $M$ joints with joint angles $\omega$, we define the forward kinematics function as $FK(\omega)$, which returns the position and orientation of the end effector in SE(3). The robot is underactuated if $M < 6$, and overactuated if $M > 6$. An underactuated is not guaranteed to reach every position and orientation in SE(3), while an overactuated robot has infinite solutions to reach a given position and orientation. We focus on the overactuated case, as the Boston Dynamics Spot arm has 6 revolute joints and we add two prismatic joints to control the base of the arm, leading to a total of 8 joints. Because the arm is overactuated, we can condition the inverse kinematics to optimize for other objectives, such as avoiding obstacles or embracing contact. This can be refferred to as conditioning the null space of the inverse kinematics. A null space is the set of all joint angles that do not affect the end effector position and orientation, so in our case of $M=8$ joints, the null space has a dimension of $M-6=2$.

We define the forward kinematics function as $FK(\omega): \mathbb{R}^M \rightarrow SE(3)$, which can be decomposed into a series of transformations from each joint. Our approach is agnostic to the specific forward kinematics implementation, as long as it is differentiable, allowing compatibility with most robot representations. Generally, the forward kinematics can be expressed as a series of matrix multiplications of the individual joint transformations. The forward kinematics can be expressed as:
\begin{equation}
\label{eq:fk}
FK(\omega) = \prod_{i=1}^{M} {}^{i-1}\!T_{i}(\omega_i) = T_{1}(\omega_1) T_{2}(\omega_2) \ldots T_{M}(\omega_M)
\end{equation}

where $T_i(\omega_i)$ is the transformation matrix for joint $i$ given its joint angle $\omega_i$. T can be computed using the Denavit-Hartenberg parameters or other methods, depending on the robot's kinematic structure.The psuedocode for the forward kinematics is shown in Algorithm \ref{alg:conditioning}.

Given a desired end effector position and orientation $X_d \in SE(3)$, we use the quasi-Newton method to iteratively solve for the next joint angles $\omega_{t+1}$ that minimize the error between the current end effector position $X_c=FK(\omega_t)$ and the desired position $X_d$. Our optimization problem is defined as:
\begin{equation}
\label{eq:ik}
\omega_{t+1} = \arg\min_{\omega} \| X_c - X_d \|^2 + \lambda R(\omega)
\end{equation}
where $R(\omega)$ is a conditioning term that encodes our secondary objectives, such as avoiding obstacles or minimizing contact forces, and $\lambda$ is a weighting factor that balances the importance of the primary and secondary objectives.

The optimization is performed continuously, updating the joint angles at each iteration. Our approach does not require an explicit Jacobian matrix or a hessian, as we use automatic differentiation to compute the gradients needed for the quasi-Newton updates. Using the automatic differentiation allows us to easily incorporate complex conditioning terms and constraints into the optimization, as long as they are differentiable.

\subsection{Implementation Details}
We implement the forward kinematics function $FK(\omega)$ using MuJoco's XML format, specifying the joint types, link lengths, and other relevant parameters. We use the \texttt{mujoco-py} library to load the model and compute the forward kinematics using PyTorch tensors to enable automatic differentiation. We define the optimization loop using PyTorch's autograd functionality to compute the gradients of the loss function with respect to the joint angles. We use the TODO optimizer from PyTorch to perform the quasi-Newton updates, as it is well-suited for problems with a moderate number of parameters and can handle non-linear objectives. Our gradient descent loop is shown in Algorithm \ref{alg:ik}.

\begin{algorithm}
\caption{Inverse Kinematics with Contact-Aware Conditioning}\label{alg:ik}
\begin{algorithmic}[1]
\Require Desired end effector pose $X_d$, initial joint angles $\omega_0$, gradient update scalar $\alpha$
\State $\omega \gets \omega_0$
\While {True}
    \State $X_c \gets FK(\omega)$ \Comment{Compute current end effector pose}
    \State $L \gets \| X_c - X_d \|^2 + \lambda R(\omega)$ \Comment{Compute loss with conditioning}
    \State $g \gets \nabla_\omega L$ \Comment{Compute gradient of loss w.r.t. joint angles}
    \State $\omega \gets \omega - \alpha g$ \Comment{Update joint angles}
    % \State \Return $\omega$ \Comment{Return optimized joint angles}
    \State \textbf{wait} until next control cycle
\EndWhile
\end{algorithmic}
\end{algorithm}

Our conditioning term $R(\omega)$ can be tuned according to the desired behavior of the robot. For example, to minimize contact forces, we can define $R(\omega)$ as the sum of squared contact forces sensed by the tactile skin. To avoid obstacles, we can define $R(\omega)$ as a penalty for joint configurations that bring the arm close to contact locations sensed by the tactile skin. The specific form of $R(\omega)$ can be adjusted based on the application and the characteristics of the tactile sensing system. The algorithm for computing the conditioning term is shown in Algorithm \ref{alg:conditioning}. Our penalty function can be a simple linear or quadratic function of the sensor readings, or a more complex function that takes into account the geometry of the robot and the environment. Our penalty function creates a new IK objective that encourages each sensor cell to move away from the contact location as shown in algorithm \ref{alg:penalty}.

        

\begin{algorithm}
\caption{Modified Forward Kinematics and Conditioning Term Computation}\label{alg:conditioning}
\begin{algorithmic}[1]
\Require Current joint angles $\omega$, tactile sensor readings $S$, contact threshold $\text{threshold}$, penalty function $P()$
\State $R \gets 0$
\State $T_0 \gets I$ \Comment{Initialize transformation matrix to identity}
\For{$i = 1$ to $M$}
        \State $T_i \gets {}^{i-1}\!T_{i}(\omega_i)$ \Comment{Compute transformation for joint $i$}
        \State $T_0 \gets T_0 \cdot T_i$ \Comment{Update cumulative transformation}
        \For{each tactile sensor $s$ on link $i$}
            \If{$S[s] > \text{threshold}$} \Comment{Check for contact}
                \State $R \gets R + P(S[s])$ \Comment{Add penalty based on sensor reading}
            \EndIf
        \EndFor
\EndFor
\State \Return $R$ \Comment{Return computed conditioning term, and end effector pose $T$}
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Penalty Function for Contact Avoidance}\label{alg:penalty}
\begin{algorithmic}[1]
\Require Sensor reading $s$: force value from tactile sensor $s_f$, location of sensor in world frame $s_p$, normal vector at sensor location $s_n$, scaling factor $\beta$
\If{$f < f_{thresh}$}
    \State \Return 0 \Comment{No penalty if force is below threshold}
\EndIf 
\State $p_{target} \gets s_p - (s_n \cdot s_f \cdot \beta$) \Comment{Compute target position away from contact}
\State \Return $\| p_{target} - s_p \|^2$ \Comment{Return squared distance as penalty}
\end{algorithmic}
\end{algorithm}

    
\subsection{Evaluation}

We evaluate our sensor and contact-aware inverse kinematics across several metrics:
\begin{enumerate}
    \item Contact localization and force intensity estimation
    \item Maximum contact force with the environment for a given trajectory
    \item Ability to address deformable contact vs rigid contact
\end{enumerate}

Metric (1) evaluates the sensor's accuracy in estimating contact locations and forces, a critical aspect to understand how well the tactile skin can inform the IK solver about the environment. 

Metric (2) assesses the real-world performance of the contact-aware IK by measuring the maximum force exerted on the environment during a predefined trajectory with a single obstacle. This metric indicates how effectively the IK can adapt to normal contact scenarios, by evaluating the saftety of the robot's movements and its ability to follow the desired trajectory. 

Metric (3) tests the IK's capability to implicitly handle different types of contact, allowing for deformable objects to be embraced while avoiding excessive forces on rigid objects. This metric is crucial for applications where the robot interacts with compliant objects, such as in agriculture or human-robot interaction. 

For each metric, we compare the performance of the contact-aware IK against a baseline IK that does not utilize tactile feedback. This comparison highlights the benefits of integrating tactile sensing into the IK process, demonstrating improvements in safety, adaptability, and task performance.